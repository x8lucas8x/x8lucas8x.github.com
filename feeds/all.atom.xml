<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Lucas' Refuge</title><link href="http://x8lucas8x.com/" rel="alternate"></link><link href="http://x8lucas8x.com/feeds/all.atom.xml" rel="self"></link><id>http://x8lucas8x.com/</id><updated>2015-10-18T20:40:00-03:00</updated><entry><title>On Integration Testing and Microservices</title><link href="http://x8lucas8x.com/on-integration-testing-and-microservices.html" rel="alternate"></link><updated>2015-10-18T20:40:00-03:00</updated><author><name>x8lucas8x</name></author><id>tag:x8lucas8x.com,2015-10-18:on-integration-testing-and-microservices.html</id><summary type="html">&lt;p&gt;To begin with, higher level (e.g. end-to-end, integration) testing lacks several
benefits of unit testing, many of which we have come to value as an industry. On
the other hand, not all bugs are apparent at an unit level. They could also
happen on the wiring between components or even at those off-the-shelf solutions
you employed to speed up your development. Yet you often heard the agile community
endorsing unit tests as the backbone of a solid testing strategy. People like
&lt;a href="https://twitter.com/mikewcohn"&gt;@mikewcohn&lt;/a&gt;, who established the initial model of the &lt;a href="http://martinfowler.com/bliki/TestPyramid.html"&gt;testing pyramid&lt;/a&gt;, often
advocate that the ratio of a particular kind of test, in your test suite, should
be inversely proportional to the degree of granularity of the tested scope.
Principle that helps a solid test suite to be built in the most cost-effective way.
And beware, since going in the opposite direction may result in an instance of the
&lt;a href="http://watirmelon.com/2012/01/31/introducing-the-software-testing-ice-cream-cone/"&gt;ice cream cone&lt;/a&gt; anti pattern. So, even though you certainly could find several
definitions for the properties of good unit tests out there, those roughly translate&amp;nbsp;to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fast&lt;/li&gt;
&lt;li&gt;Automated&lt;/li&gt;
&lt;li&gt;Isolated&lt;/li&gt;
&lt;li&gt;Informative&lt;/li&gt;
&lt;li&gt;Idempotent&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first one is easy to explain, as long-running tests are the easiest way to make
programmers develop the bad habit of avoid running tests frequently. And, if that
happens, what is the point anyway? Automated since the intention is to facilitate
adoption, not making people do repetitive work. Isolated because they should not
overlap, otherwise you would have more places to look for when something fails.
Informative, because the context of the failure should be explicit. Yep, you probably
do not want people to analyse your test&amp;#8217;s source so that they can understand what
went wrong. Finally, idempotency implies that they should behave the same, no matter
which order or how many times they were run. Believe me, tests that randomly fail
are a recipe for madness. They are worse than no tests at all, as they undermine
developers&amp;#8217; trust in their test&amp;nbsp;suite.&lt;/p&gt;
&lt;p&gt;So, how does those properties apply to higher level (e.g. end-to-end, integration)
testing. First, they are not as fast as unit tests. Especially if you are testing
two &lt;a href="http://martinfowler.com/articles/microservices.html"&gt;microservices&lt;/a&gt;, process that would involve exchanging some packets over the
network (latency sucks :/). They are not idempotent too, as there are many ways
they could go wrong. Units that rely in global state (e.g. singleton pattern)
can also suffer from that, but a proper use of dependency injection can fix
the problem. As for lost packets, network partition, good luck with it. Informative,
well, you know something in between a set of components/services is not working well.
Isolated? Nope, even though you can be cautious enough to avoid chatty
components/services, one bug in one of them and you would suddenly find yourself in
a situation in which every code path along the way fail. But hey, they could be&amp;nbsp;automated.&lt;/p&gt;
&lt;p&gt;Did you find my point of view a bit extreme? Then try &lt;a href="https://twitter.com/jbrains"&gt;@jbrains&lt;/a&gt; amazing talk titled
&lt;a href="https://vimeo.com/80533536"&gt;Integrated Tests Are A Scam&lt;/a&gt;. He goes even further by showing how the promises of high
level testing lures developers into writing more tests of the same kind that, at the end,
would provide very few coverage. Due to the combinatorial explosion of required tests,
needed for the continuously increasing code paths. Instead, he advocates that we should
spend our time with worthwhile tests. By worthwhile he means tests that help assessing
the quality of our architecture, allowing us to improve its design in the long run.
Seriously, if you want to laugh a bit with integrated tests&amp;#8217; infamous positive feedback
loop of negative emotions, watch it. Additionally, a written equivalent of it is
available at &lt;a href="http://www.jbrains.ca/permalink/integrated-tests-are-a-scam-part-1"&gt;Integrated Tests are a Scam: Part 1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In &lt;a href="http://www.jbrains.ca/permalink/part-2-some-hidden-costs-of-integration-tests"&gt;Part 2: Some Hidden Costs of Integration Tests&lt;/a&gt;, he also discusses about an important
side-effect of slow tests, they destroy developers&amp;#8217; productivity. Waiting for a few seconds
is &lt;span class="caps"&gt;OK&lt;/span&gt;, but it is not rare to find tests suites that take ten minutes or more. Unfortunately,
one cannot simply return to him/her peak performance right after such a long interruption.
In &lt;a href="http://www.jbrains.ca/permalink/part-3-the-risks-associated-with-lengthy-tests"&gt;Part 3: The risks associated with lengthy tests&lt;/a&gt;, the focus changes to the insidious
consequences of frequent false alerts, given the lack of isolation when things fail. And
with less trust in the test suite, a fear of change starts to evolve among developers.
Individuals that tend to justify their behaviour by mentioning an old engineering saying
&amp;#8220;Well, if it works, why change it?&amp;#8221;. Rationale that will ultimately lead to an architectural
stagnation and to high interest rates in the form of &lt;a href="http://martinfowler.com/bliki/TechnicalDebt.html"&gt;technical debt&lt;/a&gt;. Quite the contrary to
what you expected when you got bought into the practice of &lt;a href="http://martinfowler.com/bliki/SelfTestingCode.html"&gt;self testing code&lt;/a&gt;,&amp;nbsp;right?&lt;/p&gt;
&lt;p&gt;But do not get him wrong, his disregard for integration testing limits itself to cases
in which they are used for assessing basic correctness. Role that is better suited to
unit tests, in the first place. In &lt;a href="http://www.jbrains.ca/permalink/using-integration-tests-mindfully-a-case-study"&gt;Using integration tests mindfully: a case study&lt;/a&gt;, for
instance, he does see a value of employing integration tests for identifying system-level
issues like broken database schema, mistaken cache integration, and more complex problems.
That is, using integration tests to check the presence of a expected feature, is perfectly&amp;nbsp;fine.&lt;/p&gt;
&lt;p&gt;Still, in &lt;a href="https://vimeo.com/80533536"&gt;Integrated Tests Are A Scam&lt;/a&gt;, &lt;a href="https://twitter.com/jbrains"&gt;@jbrains&lt;/a&gt; proposes an alternative for testing the
interaction between components without resorting to integration testing. He suggests
combining collaboration and contract tests. Collaboration tests are a well known practice,
often named as &lt;a href="http://martinfowler.com/bliki/TestDouble.html"&gt;test doubles&lt;/a&gt;. More specifically, stubs are the the kind of doubles we
are interested in. Stubs tend to mimic others&amp;#8217; interfaces, but instead of doing real work,
they return pre-computed results. Behaviour that is really useful when non-deterministic
or slow operations (e.g. &lt;span class="caps"&gt;IO&lt;/span&gt;) are at stake, as we can employ fast and predictable unit-like
tests to achieve a similar end. As for contract tests, they check the format of an
component/service response, not its data. So, in the case of &lt;a href="http://martinfowler.com/articles/microservices.html"&gt;microservices&lt;/a&gt;, you would
be testing if the outcome of a particular call has the fields you expected and if so,
whether they comply with your use cases. Similarly, &lt;a href="https://twitter.com/martinfowler"&gt;@martinfowler&lt;/a&gt; also see the combination
of stubs and contract tests as a good way to tackle the slowness and unreliability of
integration tests, as stated in &lt;a href="http://martinfowler.com/bliki/IntegrationContractTest.html"&gt;integration contract test&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;One challenge though is that testing against a double does not guarantee that the external
component/service is being accurately represented. And even if so, future changes would
require the double to be updated accordingly. One alternative to streamline the updates of
stubs would be what &lt;a href="https://twitter.com/martinfowler"&gt;@martinfowler&lt;/a&gt; calls &lt;a href="http://martinfowler.com/bliki/SelfInitializingFake.html"&gt;self initialising fakes&lt;/a&gt;. Similarly, contract
testing also suffers from the same synchronisation burden, however &lt;a href="http://martinfowler.com/bliki/SelfInitializingFake.html"&gt;self initialising fakes&lt;/a&gt;
cannot help contract tests in the same manner. Additionally, there is also the possibility of
contracts and stubs getting out of sync. Problem that could be mitigated by a shared metadata
file or data structure that specifies available calls and what should be received in response,
so that you do not have to concern yourself with&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;To reduce the odds of getting out of sync, therefore breaking your test cases, or even
worse, being misled by passing tests that should have failed, it is recommended to adopt
a consumer-driven contract approach. In &lt;a href="http://martinfowler.com/articles/consumerDrivenContracts.html"&gt;Consumer-Driven Contracts: A Service Evolution
Pattern&lt;/a&gt;, the concept is explained in a relatively implementation agnostic fashion. In a
nutshell, consumer-driven contracts are a means of applying &amp;#8220;just enough&amp;#8221; validation, as
proposed by &lt;a href="https://en.wikipedia.org/wiki/Robustness_principle"&gt;John Postel&amp;#8217;s Law&lt;/a&gt;, which puts the responsibility to specify what the service
provider must comply on the clients. The service provider must then check the union of
its consumers&amp;#8217; expectations, in order to verify that there were no regressions. Additionally,
that approach has some notable design advantages. First, it facilitates evolving your
interface, as you wouldn&amp;#8217;t have to rely on schema extension points for adding new fields
to your messages. Second, since what is consumed is explicitly stated, deprecating a field
that nobody is using is way&amp;nbsp;easier.&lt;/p&gt;
&lt;p&gt;Fortunately, the usefulness of mixing stubs and consumer-driven contract tests have led
to the development of frameworks such as &lt;a href="https://github.com/realestate-com-au/pact"&gt;Pact&lt;/a&gt; and &lt;a href="https://thoughtworks.github.io/pacto/"&gt;Pacto&lt;/a&gt;, both written in Ruby. More
importantly, they facilitate your stubs and contract tests to be in sync. Personally, I
think that frameworks like that are a really promising way for guaranteeing compatibility
among services&amp;#8217; interfaces, while maintaining many of the unit testing properties. So, next
time you get yourself considering to test some &lt;a href="http://martinfowler.com/articles/microservices.html"&gt;microservices&lt;/a&gt; with integration testing,
think twice. If you just want to check compatibility among services&amp;#8217; interfaces, invest in
stubs and consumer-driven contract testing&amp;nbsp;instead.&lt;/p&gt;</summary><category term="microservices"></category><category term="integration testing"></category><category term="test doubles"></category><category term="consumer-driven contracts"></category><category term="soa"></category><category term="blog"></category></entry><entry><title>Pythonic interfaces in Go: Generators</title><link href="http://x8lucas8x.com/pythonic-interfaces-in-go-generators.html" rel="alternate"></link><updated>2015-09-12T20:40:00-03:00</updated><author><name>x8lucas8x</name></author><id>tag:x8lucas8x.com,2015-09-12:pythonic-interfaces-in-go-generators.html</id><summary type="html">&lt;p&gt;Among &lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt;&amp;#8216;s many superpowers, generators is clearly a major one. Brought from
functional languages, like &lt;a href="https://www.haskell.org/"&gt;Haskell&lt;/a&gt;, which have demonstrated how better being lazy
is in terms of speed and memory management, especially when collections&amp;#8217; size
can grow&amp;nbsp;indefinitely.&lt;/p&gt;
&lt;p&gt;In &lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt;, besides list comprehension, there are also the less known dictionary
and generator comprehensions. Being the later, what we are interested in the scope
of this post. So, considering we want a program that receives an user input and
then print all the multiples of 2 up to a certain limit, unknown a priori. For
such, we&amp;nbsp;could:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;takewhile&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;limit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;multiples_of_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;takewhile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;multiples_of_2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For the sake of simplicity, note that no error checking concerning the user input
was done in the previous example. The same rule will apply for next examples.
Despite that, one could use the yield operator instead of employing generator&amp;nbsp;comprehension:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multiples_of_2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;limit&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;StopIteration&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;

&lt;span class="n"&gt;limit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;multiples_of_2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For your information, those Python&amp;#8217;s examples were meant to &lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt; 3. As some of
you may know, the input() function, in &lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt; 2, also evals the input string,
behaviour that can lead to serious security flaws. Therefore, if you still use
&lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt; 2, favour the raw_input() function&amp;nbsp;instead.&lt;/p&gt;
&lt;p&gt;Even though we do not have the same constructs in Go, we still can employ &lt;a href="https://golang.org/"&gt;Go&lt;/a&gt;&amp;#8216;s
channels to end with a very similar effect. In such effort, two channels could be
used. One for passing the data per se and another to signal that the upper bound
limit was reached, therefore closing the data&amp;#8217;s channel. That is needed to emulate
the &lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt;&amp;#8216;s StopIteration exception, which signals that the generator is now
empty. So, without further&amp;nbsp;ado:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;multiples_of_2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;quit&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="nx"&gt;limit&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;limit&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;quit&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{}{}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;limit&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Scan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;quit&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt;

    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nb"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nb"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;multiples_of_2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that the quit channel uses an empty struct. The reason is twofold. First,
empty structs does not occupy memory space, amount that could be substantial at
scale. Second, as the &lt;a href="https://www.python.org/dev/peps/pep-0020/"&gt;Zen of Python&lt;/a&gt; states: &amp;#8220;explicit is better than implicit&amp;#8221;.
So, by passing an empty struct we make it clear that the whole point of that
particular channel is for signalling only, therefore avoiding users to wonder if
there is a difference between true and false if, otherwise, we have declared that
channel as a bool channel for&amp;nbsp;instance.&lt;/p&gt;
&lt;p&gt;Besides that, the multiples_of_2&amp;#8217;s interface expose a lot about the business logic
of our custom generator. Besides that, the whole process of initialising/closing a
channel is quite repetitive. And as the &lt;a href="https://en.wikipedia.org/wiki/Don't_repeat_yourself"&gt;&lt;span class="caps"&gt;DRY&lt;/span&gt;&lt;/a&gt; principle preaches, repetition is the
root of all evil. Not to mention the fact that we could solve this problem with a
single channel, instead of two. But fear not, that required channel can be
encapsulated inside multiples_of_2, leading to an interface that is very similar to
the pythonic&amp;nbsp;one.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;multiples_of_2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;limit&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nb"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;limit&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;limit&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Scan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;multiples_of_2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So, that is all. At the expense of some extra work in our APIs, we can provide
very pythonic interfaces for lazy evaluated lists in &lt;a href="https://golang.org/"&gt;Go&lt;/a&gt;. Now without the need
to worry about channels or concurrency at all. As a matter of fact, synchronous
APIs, like the last example, should be favoured in &lt;a href="https://golang.org/"&gt;Go&lt;/a&gt;, given using synchronous
APIs in a asynchronous manner is easy in &lt;a href="https://golang.org/"&gt;Go&lt;/a&gt;, while the contrary is&amp;nbsp;not.&lt;/p&gt;</summary><category term="golang"></category><category term="python"></category><category term="zen"></category><category term="generators"></category></entry><entry><title>Connected, but still not interoperable</title><link href="http://x8lucas8x.com/connected-but-still-not-interoperable.html" rel="alternate"></link><updated>2015-09-24T20:40:00-03:00</updated><author><name>x8lucas8x</name></author><id>tag:x8lucas8x.com,2015-09-04:connected-but-still-not-interoperable.html</id><summary type="html">&lt;p&gt;Right now IoT is composed by a jungle of different solutions. You can probably outline
those that seem more promising. In the networking spectrum there is a whole stack
solutions, which tries to provide you not only data link layer features but also
routing, addressing and some even encryption, those are mainly Zigbee, Z-Wave,
Bluetooth and WirelessHart. On the other hand you also have &lt;span class="caps"&gt;WIFI&lt;/span&gt;, raw &lt;span class="caps"&gt;IEEE&lt;/span&gt; 802.15.4,
&lt;span class="caps"&gt;GPRS&lt;/span&gt; and all sort of radios operating in sub-gigahertz frequency ranges. Each has
an use case of its own. Z-Wave, for instance, is more present in home automation,
Bluetooth V4 is usually the right one for wearables, WirelessHart is an adaption
of the Highway Addressable Remote Transducer Protocol (&lt;span class="caps"&gt;HART&lt;/span&gt;) protocol for industrial
wireless networks and Zigbee is the wild card among them (i.e. thanks to &lt;span class="caps"&gt;DIGI&lt;/span&gt;&amp;#8217;s
amazing &lt;span class="caps"&gt;AT&lt;/span&gt; programming&amp;nbsp;interface).&lt;/p&gt;
&lt;p&gt;Along with that there is also efforts to bring the &lt;span class="caps"&gt;IP&lt;/span&gt; protocol to the constrained devices
like those that use &lt;span class="caps"&gt;IEEE&lt;/span&gt; 802.15.4 and its variations. Well, the advantages are many. First
there is the seamless exchange of information between devices utilizing any &lt;span class="caps"&gt;IP&lt;/span&gt;-enabled
&lt;span class="caps"&gt;MAC&lt;/span&gt;/&lt;span class="caps"&gt;PHY&lt;/span&gt; (e.g. Wi-Fi, Ethernet). Second we cannot forget the battle-tested tooling all
those years of &lt;span class="caps"&gt;IP&lt;/span&gt; predominance have provided us (e.g. ping, traceroute, netcat, wireshark,
tcpdump). The &lt;a href="http://www.ipso-alliance.org/"&gt;&lt;span class="caps"&gt;IPSO&lt;/span&gt; Alliance&lt;/a&gt; is one of the major advocates in this matter. They have several
whitepapers publicising standards like &lt;a href="http://www.ipso-alliance.org/downloads/6LoWPAN"&gt;6LowPan&lt;/a&gt;, an &lt;span class="caps"&gt;IPV6&lt;/span&gt;-compatible addressing with better
header compression, and &lt;a href="http://www.ipso-alliance.org/downloads/RPL"&gt;&lt;span class="caps"&gt;RPL&lt;/span&gt;&lt;/a&gt;, a mesh-enabled routing protocol for low power and lossy networks.
The &lt;a href="http://www.zigbee.org/"&gt;Zigbee Alliance&lt;/a&gt; also realised the advantages of IPv6-based wireless mesh networking and
created ZigBee &lt;span class="caps"&gt;IP&lt;/span&gt;, and open standard built on top of &lt;span class="caps"&gt;IEEE&lt;/span&gt; 802.15.4 that provides end-to-end
IPv6&amp;nbsp;networking.&lt;/p&gt;
&lt;p&gt;On top of &lt;span class="caps"&gt;IP&lt;/span&gt;, on the application level, &lt;a href="http://mqtt.org/news"&gt;&lt;span class="caps"&gt;MQTT&lt;/span&gt;&lt;/a&gt; and &lt;a href="https://tools.ietf.org/html/rfc7252"&gt;&lt;span class="caps"&gt;COAP&lt;/span&gt;&lt;/a&gt; shine. The first is a lightweight
&lt;span class="caps"&gt;PUB&lt;/span&gt;-&lt;span class="caps"&gt;SUB&lt;/span&gt; protocol based on &lt;span class="caps"&gt;TCP&lt;/span&gt;. Now you may wonder if &lt;a href="http://mqtt.org/news"&gt;&lt;span class="caps"&gt;MQTT&lt;/span&gt;&lt;/a&gt; is appropriate for wireless
sensor networks. In fact anything &lt;span class="caps"&gt;TCP&lt;/span&gt; based is not by design, but in such cases you can use
&lt;a href="http://mqtt.org/news"&gt;&lt;span class="caps"&gt;MQTT&lt;/span&gt;-&lt;span class="caps"&gt;SN&lt;/span&gt;&lt;/a&gt;, a &lt;span class="caps"&gt;UDP&lt;/span&gt; based variation of &lt;a href="http://mqtt.org/news"&gt;&lt;span class="caps"&gt;MQTT&lt;/span&gt;&lt;/a&gt; that is especially tailored for low-cost and
low-power sensor devices that run over bandwidth-constrained wireless networks. While &lt;a href="https://tools.ietf.org/html/rfc7252"&gt;&lt;span class="caps"&gt;COAP&lt;/span&gt;&lt;/a&gt;
is a lightweight &lt;span class="caps"&gt;HTTP&lt;/span&gt; compatible protocol, based on &lt;span class="caps"&gt;UDP&lt;/span&gt;, with support for multicasting and
service discovery. Both of them are quite popular and you can probably find an implementation
for your favourite programming language or IoT platform (e.g. &lt;a href="http://contiki-os.org/"&gt;Contiki &lt;span class="caps"&gt;OS&lt;/span&gt;&lt;/a&gt;, &lt;a href="https://tools.ietf.org/html/rfc7390"&gt;Arduino&lt;/a&gt;).
Unfortunately, given a non-&lt;span class="caps"&gt;IP&lt;/span&gt; network, developing a gateway to map your custom protocol
in the interface your backend/server uses and vice-versa is a necessary&amp;nbsp;burden.&lt;/p&gt;
&lt;p&gt;So, there is certainly no doubt there were major progresses on the connectivity front, but
still something is absent in this equation. Connectivity is certainly necessary but IoT is as
much about connectivity as the internet is about the web. That vision those big players describe
of smart Xs, being X anything, autonomously interacting among themselves is heavily dependent
of those devices being able to discover each other and access their functionalities, without
being explicitly pre-programmed to do so. You probably saw companies like &lt;a href="http://www.smartthings.com/"&gt;Smart Things&lt;/a&gt;,
&lt;a href="https://ninjablocks.com/"&gt;Ninja Blocks&lt;/a&gt; or the former &lt;a href="http://revolv.com/"&gt;Revolv&lt;/a&gt;, bought by &lt;a href="https://nest.com/"&gt;Nest&lt;/a&gt;, stating that their platforms/hubs
supports different vendors or &amp;#8220;play well with others&amp;#8221;, which is great but has its own&amp;nbsp;limitations.&lt;/p&gt;
&lt;p&gt;Up to now, in platforms like the aforementioned, integration of new products occurs in a
incremental fashion. So if you want to support Phillip&amp;#8217;s &lt;a href="http://www2.meethue.com/pt-br/"&gt;Hue&lt;/a&gt; or &lt;a href="https://www.lifx.com/"&gt;&lt;span class="caps"&gt;LIFX&lt;/span&gt;&lt;/a&gt; lamps, you will have
to read the documentation of their &lt;span class="caps"&gt;REST&lt;/span&gt; &lt;span class="caps"&gt;API&lt;/span&gt;. Which seems great given &lt;span class="caps"&gt;REST&lt;/span&gt; apis are easy to
integrate, but the crude reality of IoT is way less welcoming. In most you cases, you will
find yourself with vertically integrated systems that do not permit easy third-party integration.
And even if they permitted, the manual process of integrating with new devices and/or platforms
have two&amp;nbsp;problems.&lt;/p&gt;
&lt;p&gt;First, a great deal of products does not provide public documented APIs for third-parties.
And the reason is that, currently, most vendors tend to sell a solution, from hardware to user
interface, therefore not caring for those who want to use their products differently from what
they envisaged (i.e. makers suffer :/). Consider &lt;a href="https://www.plugwise.com/"&gt;Plugwise&lt;/a&gt;, for instance, they have one of the
most complete energy management solutions out there, but without a consistent effor to provide
a public &lt;span class="caps"&gt;API&lt;/span&gt; or &lt;span class="caps"&gt;SDK&lt;/span&gt;. You may even find unofficial libraries, made by someone who probably had
to sniffer &lt;a href="https://www.plugwise.com/"&gt;Plugwise&lt;/a&gt;&amp;#8216;s devices in order to reverse engineer their proprietary protocol. But
using those, you would not have any guarantee of future support. Besides that it is common
for unofficial libraries not to be feature complete, so good luck if you want to use the most
recent&amp;nbsp;capabilities.&lt;/p&gt;
&lt;p&gt;Second, manual integration does not scale. Vendors may try to pinpoint the most popular
products, to focus their integrations efforts, or form partnerships, but that degree of
interoperability will come at the expense of tight vendor integration with specific&amp;nbsp;partners.&lt;/p&gt;
&lt;p&gt;To solve those problems, devices need to discover and access each other functionalities, not
necessarily directly like &lt;span class="caps"&gt;M2M&lt;/span&gt; scenarios portrait. And for such two things are required. First
a data model that could explicitly state what each piece of data is about, so that you do not
have to read a manual to realise that a sensor is measuring temperature in Celsius. Ontologies
are usually the answer in such cases, but &lt;a href="http://www.w3.org/2001/sw/wiki/OWL"&gt;&lt;span class="caps"&gt;OWL&lt;/span&gt;&lt;/a&gt; and &lt;a href="http://www.w3.org/2001/sw/wiki/RDF"&gt;&lt;span class="caps"&gt;RDF&lt;/span&gt;&lt;/a&gt; are not appropriate given the bandwidth
limitations. The &lt;a href="http://www.ipso-alliance.org/"&gt;&lt;span class="caps"&gt;IPSO&lt;/span&gt; Alliance&lt;/a&gt; tried to fill this gap with its &lt;a href="http://www.ipso-alliance.org/smart-object-guidelines"&gt;Smart Objects&lt;/a&gt; specification,
which describes a reusable data model for IoT. That data model defines a set of data types
and structures that can be used by different devices, in order to enable them to interoperate
since the semantics is now in the data itself. Still, despite the &lt;a href="http://www.ipso-alliance.org/smart-object-guidelines"&gt;Smart Objects&lt;/a&gt; specification,
ontologies have an important role at the users level, as the tooling from semantic web
technologies (e.g. &lt;a href="http://www.w3.org/2001/sw/wiki/SPARQL"&gt;&lt;span class="caps"&gt;SPARQL&lt;/span&gt;&lt;/a&gt;, &lt;a href="http://www.w3.org/2001/sw/wiki/OWL"&gt;&lt;span class="caps"&gt;OWL&lt;/span&gt;&lt;/a&gt;, &lt;a href="http://www.w3.org/2001/sw/wiki/RDF"&gt;&lt;span class="caps"&gt;RDF&lt;/span&gt;&lt;/a&gt;) can provide great value for those interested in
composing their own IoT solutions by accessing higher level&amp;nbsp;services.&lt;/p&gt;
&lt;p&gt;Although being able to determine the content of the messages sent by sensors is important, no
equivalent exists in terms of actuation. And that is key to a large adoption of IoT, especially
in the end-consumer market. Right now, businesses can get value by tracking trends and analysing
data, but for end-consumers automation is the real killer application. And by automation I mean
not only actuation, that translates itself in an event in the physical world, but also remote
configuration of these devices. All that provided, without devices being pre-programmed to do
so, would be huge. But, unfortunately, no lightweight UPnP exist for the IoT&amp;nbsp;yet.&lt;/p&gt;</summary><category term="iot"></category><category term="ioe"></category><category term="automation"></category><category term="networking"></category></entry><entry><title>Zeroless</title><link href="http://x8lucas8x.com/zeroless.html" rel="alternate"></link><updated>2015-08-18T21:16:00-03:00</updated><author><name>x8lucas8x</name></author><id>tag:x8lucas8x.com,2015-08-18:zeroless.html</id><summary type="html">&lt;p&gt;Using &lt;a href="http://zeromq.org/"&gt;ZeroMQ&lt;/a&gt; in Python with &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt;, however, always made me feel like I&amp;#8217;m coding in
C/C++, which I also love by the way. Unfortunately, that lack of &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt; &lt;span class="caps"&gt;API&lt;/span&gt;&amp;#8217;s, if I
may say, &amp;#8220;pythonicity&amp;#8221;, just felt wrong to me. And by the end of last January, I
decided to do something about it. So that is how &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt; was&amp;nbsp;born.&lt;/p&gt;
&lt;p&gt;My mission was to leverage on &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt; to build a more elegant wrapper for &lt;a href="http://zeromq.org/"&gt;ZeroMQ&lt;/a&gt;.
Something more aligned with the python way of doing things. And, to a certain degree,
I have succeeded. However, I have never made a comprehensive effort to publicise
&lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt; in any way so, in this post, I hope not only to explain how &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;
differs from &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt; but also to reach a greater audience, that may be as enthusiastic
about &lt;a href="http://zeromq.org/"&gt;ZeroMQ&lt;/a&gt; as myself. Therefore, without further ado, here goes some of the design
decisions I have made for &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;:&lt;/p&gt;
&lt;h1&gt;&lt;span class="caps"&gt;TCP&lt;/span&gt; only for the&amp;nbsp;win&lt;/h1&gt;
&lt;p&gt;Ok, I know &lt;span class="caps"&gt;PGM&lt;/span&gt;, &lt;span class="caps"&gt;INPROC&lt;/span&gt; and &lt;span class="caps"&gt;IPC&lt;/span&gt; have their use cases. &lt;span class="caps"&gt;PGM&lt;/span&gt; for instance provides a
Publish/Subscribe specific transport, that scales better than &lt;span class="caps"&gt;TCP&lt;/span&gt; in the
Publish/Subscribe use case, as it cut out the &lt;span class="caps"&gt;ACK&lt;/span&gt; flood publishers gets on
every new message. There are also some extra reliability, that you also cannot
find in &lt;span class="caps"&gt;TCP&lt;/span&gt;. &lt;span class="caps"&gt;IPC&lt;/span&gt;, on the other hand, is a pattern agnostic way of providing more
efficient inter-process communication than traditional networking, but is Unix-like
only. As for &lt;span class="caps"&gt;INPROC&lt;/span&gt;&amp;#8217;s particular case, which efficient applicability is being
hindered by the Python&amp;#8217;s &lt;span class="caps"&gt;GIL&lt;/span&gt;, I do not see why bother with&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Nevertheless, I have a feeling that the vast majority of the users, like myself,
are quite good with just &lt;span class="caps"&gt;TCP&lt;/span&gt;. Which is exactly what you need when building really
horizontally scalable networked services, especially in this time of a renewed
vision for &lt;span class="caps"&gt;SOA&lt;/span&gt;, with microservices having a lot of attention. So let us just use
&lt;span class="caps"&gt;TCP&lt;/span&gt; and free our minds to think about other&amp;nbsp;matters.&lt;/p&gt;
&lt;h1&gt;No more&amp;nbsp;contexts&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt; applications require users to create a context, in order to instantiate
sockets. Technically, a context serves as a container for all your sockets and
usually one of it, per process, is just what you need. As a matter of fact, you
could have more, but why bother your runtime with more event loops, for your
socket stuff, when one suffices? Also, if you are using &lt;span class="caps"&gt;INPROC&lt;/span&gt; as transport,
you may also need to share a context for the communication to happen. But again,
if &lt;span class="caps"&gt;INPROC&lt;/span&gt; is is not that useful in Python as aforementioned, do we really need
explicitly manage&amp;nbsp;contexts?&lt;/p&gt;
&lt;p&gt;Not at all, so that is why in &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt; you just have to manage Clients, sockets
that connect, and Servers, sockets that bind, without concerning yourself with
contexts ;). For instance, in order to instantiate a client you&amp;nbsp;would:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Client&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c"&gt;# You could use connect_local(port=12345) as well&lt;/span&gt;
&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;12345&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Similarly, for servers, you&amp;nbsp;would:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Server&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;12345&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# No need to call bind here&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, note that no real connect/bind will occur unless you instantiate a
messaging pattern, which are the subject of our next&amp;nbsp;topic.&lt;/p&gt;
&lt;h1&gt;Like a factory method&amp;nbsp;pattern&lt;/h1&gt;
&lt;p&gt;One thing I never liked about &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt; sockets&amp;#8217;s instantiation is that we have to call
a method called socket, which receives an enum representing the type of the socket.
Why don&amp;#8217;t they just provide a separate method for every socket possible, like as if
it was a factory method pattern kind of interface. That would allow a more
straightforward experience for developers, that could then rely on their favourite
&lt;span class="caps"&gt;IDE&lt;/span&gt;&amp;#8217;s code complete to quickly understand what kind of sockets and parameters they
could set. That enum approach, however, will probably make your users go to the
documentation, but solely because of the way the &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt;&amp;#8216;s interface&amp;nbsp;is.&lt;/p&gt;
&lt;p&gt;In &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;, we fixed that, so you don&amp;#8217;t need to check the documentation every
time you want to instantiate a socket, instead just have a descent code complete
support and you are done. For instance, compare how you would instantiate a
publisher socket with &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Server&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;12345&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Connections&amp;nbsp;awareness&lt;/h1&gt;
&lt;p&gt;One of the questions you may ask is to whom your clients are connected to. And
for that, &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt; cannot help you. Unless you manage that list off connections by
yourself, you wouldn&amp;#8217;t be able to get it afterwards. Therefore, in &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;,
we provide an addresses property, so that you can retrieve all your ip and port
pairs as a list of tuples. But that is only for clients of course, as there is
no way to know which sockets are connected to your server without building
some sort of infrastructure for that&amp;nbsp;yourself.&lt;/p&gt;
&lt;h1&gt;Subscribe should not be&amp;nbsp;tricky&lt;/h1&gt;
&lt;p&gt;In terms of interface, the subscribe case is particularly problematic in &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt;.
One must use the not so intuitive &lt;a href="https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Context.setsockopt"&gt;setsockopt()&lt;/a&gt; method, in
order to define the topics it subscribes to. Like in the following&amp;nbsp;snippet:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;socket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;&lt;span class="caps"&gt;SUB&lt;/span&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setsockopt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;&lt;span class="caps"&gt;SUBSCRIBE&lt;/span&gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# Subscribe to all topics&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I believe most new &lt;a href="http://zeromq.org/"&gt;ZeroMQ&lt;/a&gt;&amp;#8216;s user get this wrong at first, as they supose no
topic means you are subscribed to all topics, and keep asking himself/herself why
that damn subscriber socket does not receives your published&amp;nbsp;messages.&lt;/p&gt;
&lt;p&gt;In &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;, we fixed that, so that you don&amp;#8217;t have to instantiate your socket
and set something as essential as a topic, in the subscribe case, via some kind
of &amp;#8220;obscure&amp;#8221; method. Just compare how you would instantiate a subscriber socket
with &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;listen_for_pub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;topics&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Generators and high-order functions as first class&amp;nbsp;citizens&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt; sockets tend to use &lt;a href="https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Socket.send"&gt;send()&lt;/a&gt; and &lt;a href="https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Socket.recv"&gt;recv()&lt;/a&gt; methods
for the message exchange part. However, it always felt wrong to me to do stuff&amp;nbsp;like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c"&gt;# do something with data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That is, if Python has built-in support for iterables, or generators if you prefer,
why don&amp;#8217;t we just do something&amp;nbsp;like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;listen_for_push&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Server&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;12345&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pull&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;listen_for_push&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# do something with data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Way more idiomatic to read incoming messages that way, right? As for sending them,
I also followed a different&amp;nbsp;path.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Msg1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Therefore, in &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;, every time you instantiate a message pattern that is
suposed to send messages, use it as a function. Otherwise, treat it as a&amp;nbsp;generator.&lt;/p&gt;
&lt;h1&gt;Multi-part made&amp;nbsp;easy&lt;/h1&gt;
&lt;p&gt;In &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt;, if you want to send a multipart message, you have to use the
&lt;a href="https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Socket.recv_multipart"&gt;recv_multipart()&lt;/a&gt; and &lt;a href="https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Socket.send_multipart"&gt;send_multipart()&lt;/a&gt;
methods. Methods that instead of a single message, will deal with a list of them.
In &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;, I favoured consistency for a quicker and easier learning path,
therefore there is no difference between the singlepart and the multipart&amp;nbsp;&lt;span class="caps"&gt;API&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;If you want to send a multipart message, just consider that your send function have
a printf like interface and you are set. So, for instance, if you want to send an
id separated from your message body, you&amp;nbsp;could:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;span class="caps"&gt;OK&lt;/span&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Additionally, if someone send you a multipart message, your generator will return a
tuple with all of its parts. As a result of that, to get the message from the previous
example you would need&amp;nbsp;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;listen_for_push&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Server&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;12345&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pull&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;listen_for_push&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# do something with id and msg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;The&amp;nbsp;future&lt;/h1&gt;
&lt;p&gt;Although feature parity was never part of my plans, there still some of &lt;a href="https://github.com/zeromq/pyzmq"&gt;PyZMQ&lt;/a&gt;&amp;#8216;s
functionalities I would like to provide in &lt;a href="https://github.com/zmqless/python-zeroless"&gt;Zeroless&lt;/a&gt;. Like both &lt;a href="https://zeromq.github.io/pyzmq/api/zmq.html#poller"&gt;poller&lt;/a&gt;
and &lt;a href="https://zeromq.github.io/pyzmq/api/zmq.devices.html"&gt;devices&lt;/a&gt; APIs, for instance. So expect more on the way o/. While
that, if you felt compelled to help shape this project, please clone our &lt;a href="https://github.com/zmqless/python-zeroless.git"&gt;repository&lt;/a&gt;
and see our &lt;a href="http://python-zeroless.readthedocs.org/en/latest/development.html#contributing"&gt;guidelines&lt;/a&gt;.&lt;/p&gt;</summary><category term="networking"></category><category term="python"></category><category term="zeroless"></category><category term="zeromq"></category><category term="pyzmq"></category><category term="messaging"></category><category term="blog"></category></entry><entry><title>Moving to Pelican</title><link href="http://x8lucas8x.com/moving-to-pelican.html" rel="alternate"></link><updated>2015-08-18T20:40:00-03:00</updated><author><name>x8lucas8x</name></author><id>tag:x8lucas8x.com,2015-08-08:moving-to-pelican.html</id><summary type="html">&lt;p&gt;The motivation was twofold. First, provide me more control over my own blog. Second,
learn more about web technologies (i.e. &lt;span class="caps"&gt;HTML&lt;/span&gt;, &lt;span class="caps"&gt;CSS&lt;/span&gt;, &lt;span class="caps"&gt;JS&lt;/span&gt;) in the way. So, that&amp;#8217;s it.
Hope you can find some interesting posts here in the near future&amp;nbsp;o/.&lt;/p&gt;</summary><category term="pelican"></category><category term="publishing"></category><category term="personal"></category><category term="blog"></category></entry></feed>